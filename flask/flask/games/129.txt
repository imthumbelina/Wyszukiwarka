Jump to content Google Sign in options Remember me This is not recommended for shared computers Sign in anonymously Don't add me to the active users list Privacy Policy      Sign In    Create Account 6 Search Advanced Search section: Google This database Forums Members Help Files Developer Journals Gallery Calendar Downloads Resources Store Classifieds Tracker Links Home For Beginners Articles All Articles Post an Article Technical Game Programming General Programming Graphics Programming and Theory DirectX and XNA OpenGL Multiplayer and Network Programming Artificial Intelligence Math and Physics Mobile Development APIs and Tools Creative Game Design Music and Sound Visual Arts Business Breaking into the Industry Production and Management Interviews Business and Law Event Coverage Forums All Forums Community Interaction GDNet Lounge Coding Horrors Article Writing GDNet Comments, Suggestions and Ideas Your Announcements Technical Game Programming General Programming Graphics Programming and Theory DirectX and XNA OpenGL Multiplayer and Network Programming Artificial Intelligence Math and Physics Mobile & Console Development Build Systems & Source Control APIs and Tools Creative Game Design Writing For Games Music and Sound Visual Arts Gallery Business Breaking into the Industry Business & Law Production & Management Community Developer Journals Screenshot Showdown GDNet+ Subscriptions Gallery Books Store Top Members Classifieds Job Offers Contractors For Hire Contract Projects Hobbyist Projects Marketplace Home » Articles » Technical » Math and Physics » Article: The Matrix and Quaternions FAQ Watched Content New Content Banner advertising on our site currently available from just $5! 1. Learn about the promo. 2. Sign up for GDNet+. 3. Set up your advert! More Like This Quaternion Powers 3D Matrix Mayhem 3D Matrix Math Demystified Orientation with Quaternions Vectors and Matrices: A Primer Categories (See All) Technical Game Programming General Programming Graphics Programming and Theory DirectX and XNA OpenGL Multiplayer and Network Programming Artificial Intelligence Math and Physics Mobile Development APIs and Tools Creative Game Design Music and Sound Visual Arts Business Event Coverage Breaking Into the Industry Business and Law Interviews Production and Management Gamedev.net Help Recent Resources Improve Player Retention Reacting to Behavior [Server Scripts] May 12 2015 04:22 PM | 6 Comments Dynamic vertex pulling with D3D11 Apr 29 2015 11:37 AM | 5 Comments Giving Away $17,000 Worth of Toto Temple Deluxe at Pax East Apr 27 2015 07:27 AM | 2 Comments Everything You Ever Wanted to Know About Authenticode Signing May 08 2015 11:06 AM | 5 Comments Shader Cross Compilation and Savvy - The Smart Shader Cross Compiler May 15 2015 09:23 AM | 0 Comments Crowdin: Localizing Without Pain Apr 15 2015 11:07 AM | 1 Comments Automated Deployment of Your Game Apr 13 2015 10:47 AM | 3 Comments Show more » | View all recent resources» 0 Like 0Likes Dislike The Matrix and Quaternions FAQ By Andreas | Published Feb 11 2002 05:46 AM in Math and Physics matrix matrices rotation version html using calculate quaternion Hide If you find this article contains errors or problems rendering it unreadable (missing images or files, mangled code, improper text formatting, etc) please contact the editor so corrections can be made. Thank you for helping us improve this resource (Editor's Note - This article requires additional formatting work and is incomplete) Version 1.21  30th November 2003 ------------------------------- Please mail feedback to matrix_faq@j3d.org with a subject starting with  MATRIX-FAQ (otherwise my spam filter will simply kill your message). Any additional suggestions or related questions are welcome. Just send E-mail to the above address. The latest copy of this FAQ can be found at the following web page: http://www.j3d.org/matrix_faq/matrfaq_latest.html Feel free to distribute or copy this FAQ as you please. Contributions -------------   Introduction I1: Steve ?????   Correction to Q55 until Q59:   Andreas Junghanns   Correction to Q50: Morten Ofstad   Note to Q39: Tom Nuydens   Corrections to Q29 and Q37: Eric Reiss   Clarification to Q56: Duncan Murdoch   Clarification to Q37: Ron Avitzur   Correction to Q1: Mona Wong   Corrections to Q36 and Q37: Eric Reiss   Improvement to Q34 and Q38: Jon Watte   Warning and alternative to Q58 and Q59: Paul Pedriana   Correction (and optimization [Lee]) to Q53: Eleanor Groundwater and Lee Morgan   Improvement to Q39: jhunpingco   Corrections to Q11 and optimization to Q12: Gordon   Corrections to Q54 to Q60: Eleanor Groundwater   Corrections and improvements to Q23 and Q24: Ben Houston   Addition to Q39: Jon Watte   Correction to Q61: Adam D. Moss   Addition of Q63: Mike Cline   Addition of I2: Jacob Marner   Correction to Q38 and inception of I2: Armin M?ller   Addition of Q60: Pablo Figueroa   Correntions and additions to Q14, Q16, Q21 and Q34: Tronster Hartley   Correction to Q12 and Q54: Frank DJ   Correction to Q34: Robert Funnell History ------- I (Andreas) tried to find "hexapod@(no-spam)netcom.com" who seemed to have maintained this for a while, but the site at netcom.com doesn't exist anymore, emails bounce.  Since I (and colleques) wasted quite some time figuring out what was wrong with some of the algorithms given in the earlier versions of this document, I decided to correct it and put it back on the web. The formerly given sites for the location of these documents do not exist anymore:   ftp://ftp.netcom.com/pub/he/hexapod/index.html   http://www.glue.umd.edu/~rsrodger   Versions, dates and links to local copies (so you can compare): matrfaq_1.02.html: Version 1.2  2nd September 1997 matrfaq_1.04.html: Version 1.4  26th December 1998 matrfaq_1.06.html: Version 1.6  30th September 2000 matrfaq_1.07.html: Version 1.7  20th December 2000 matrfaq_1.08.html: Version 1.8  21th December 2000 matrfaq_1.09.html: Version 1.9  16th January 2001 matrfaq_1.10.html: Version 1.10  30th January 2001 matrfaq_1.11.html: Version 1.11  9th February 2001 matrfaq_1.12.html: Version 1.12  26th March 2001 matrfaq_1.13.html: Version 1.13  20th July 2001 matrfaq_1.14.html: Version 1.14  17th August 2001 matrfaq_1.15.html: Version 1.15  20th August 2001 matrfaq_1.16.html: Version 1.16  2nd October 2001 matrfaq_1.17.html: Version 1.17  30th November 2001 matrfaq_1.18.html: Version 1.18  27th January 2002 matrfaq_1.19.html: Version 1.19  20th March 2002 matrfaq_1.20.html: Version 1.20  31st January 2002 matrfaq_1.21.html: Version 1.21  30th November 2003 Please refrain from asking me math questions. I am only maintaining this FAQ and have very little knowledge about the subject. But, if you have a question that is not answered by this FAQ and later happen to find the answer and believe it to be relevant for this FAQ (or its readers), please send all relevant information, hopefully in a pre-digested form, to me to be included here. Thanks! If you prefer to appear as "anonymous" in the contributions list, let me know, otherwise I'll just put you down with whatever name I can gather from your email header. Introduction ------------ I1.  Important note relating to OpenGL and this document I2.  Important note with respect to normalized inputs Questions --------- BASICS ======  Q1. What is a matrix?  Q2. What is the order of a matrix?  Q3. How do I represent a matrix using the C/C++ programming languages?  Q4. What are the advantages of using matrices?  Q5. How do matrices relate to coordinate systems? ARITHMETIC ==========  Q6. What is the identity matrix?  Q7. What is the major diagonal matrix of a matrix?  Q8. What is the transpose of a matrix?  Q9. How do I add two matrices together? Q10. How do I subtract two matrices? Q11. How do I multiply two matrices together? Q12. How do I square or raise a matrix to a power? Q13. How do I multiply one or more vectors by a matrix? DETERMINANTS AND INVERSES ========================= Q14. What is the determinant of a matrix? Q15. How do I calculate the determinant of a matrix? Q16. What are Isotropic and Anisotropic matrices? Q17. What is the inverse of a matrix? Q18. How do I calculate the inverse of an arbitrary matrix? Q19. How do I calculate the inverse of an identity matrix? Q20. How do I calculate the inverse of a rotation matrix? Q21. How do I calculate the inverse of a matrix using Kramer's rule? Q22. How do I calculate the inverse of a 2x2 matrix? Q23. How do I calculate the inverse of a 3x3 matrix? Q24. How do I calculate the inverse of a 4x4 matrix? Q25. How do I calculate the inverse of a matrix using linear equations? TRANSFORMS ========== Q26. What is a rotation matrix? Q27. How do rotation matrices relate to coordinate systems? Q28. How do I generate a rotation matrix in the X-axis? Q29. How do I generate a rotation matrix in the Y-axis? Q30. How do I generate a rotation matrix in the Z-axis? Q31. What are Euler angles? Q32. What are yaw, roll and pitch? Q33. How do I combine rotation matrices? Q34. What is Gimbal Lock? Q35. What is the correct way to combine rotation matrices? Q36. How do I generate a rotation matrix from Euler angles? Q37. How do I generate Euler angles from a rotation matrix? Q38. How do I generate a rotation matrix for a selected axis and angle? Q39. How do I generate a rotation matrix to map one vector onto another? Q40. How do I use matrices to convert between two coordinate systems? Q41. What is a translation matrix? Q42. What is a scaling matrix? Q43. What is a shearing matrix? Q44. How do I perform linear interpolation between two matrices? Q45. How do I perform cubic interpolation between four matrices? Q46. How can I render a matrix? QUATERNIONS =========== Q47.  What are quaternions? Q48.  How do quaternions relate to 3D animation? Q49.  How do I calculate the conjugate of a quaternion? Q50.  How do I calculate the inverse of a quaternion? Q51.  How do I calculate the magnitude of a quaternion? Q52.  How do I normalise a quaternion? Q53.  How do I multiply two quaternions together? Q54.  How do I convert a quaternion to a rotation matrix? Q55.  How do I convert a rotation matrix to a quaternion? Q56.  How do I convert a rotation axis and angle to a quaternion? Q57.  How do I convert a quaternion to a rotation axis and angle? Q58.  How do I convert spherical rotation angles to a quaternion? Q59.  How do I convert a quaternion to spherical rotation angles? Q60.  How do I convert Euler rotation angles to a quaternion? Q61.  How do I use quaternions to perform linear interpolation between matrices? Q62.  How do I use quaternions to perform cubic interpolation between matrices? Q63.  How do I use quaternions to rotate a vector? Introduction ------------ I1. Important note relating to OpenGl and this document -------------------------------------------------------   In this document (as in most math textbooks), all matrices are drawn   in the standard mathematical manner.  Unfortunately graphics libraries   like IrisGL, OpenGL and SGI's Performer all represent them with the   rows and columns swapped.   Hence, in this document you will see (for example) a 4x4 Translation   matrix represented as follows:           | 1  0  0  X |           |            |           | 0  1  0  Y |       M = |            |           | 0  0  1  Z |           |            |           | 0  0  0  1 |   In Performer (for example) this would be populated as follows:     M[0][1] = M[0][2] = M[0][3] =     M[1][0] = M[1][2] = M[1][3] =     M[2][0] = M[2][1] = M[2][3] = 0 ;     M[0][0] = M[1][1] = M[2][2] = m[3][3] = 1 ;     M[3][0] = X ;     M[3][1] = Y ;     M[3][2] = Z ;   ie, the matrix is stored like this:           | M[0][0]  M[1][0]  M[2][0]  M[3][0] |           |                                    |           | M[0][1]  M[1][1]  M[2][1]  M[3][1] |       M = |                                    |           | M[0][2]  M[1][2]  M[2][2]  M[3][2] |           |                                    |           | M[0][3]  M[1][3]  M[2][3]  M[3][3] |   OpenGL uses a one-dimensional array to store matrices - but fortunately,   the packing order results in the same layout of bytes in memory - so   taking the address of a pfMatrix and casting it to a float* will allow   you to pass it directly into routines like glLoadMatrixf.   In the code snippets scattered throughout this document, a one-dimensional   array is used to store a matrix. The ordering of the array elements is   transposed with respect to OpenGL.      This Document                  OpenGL         | 0  1  2  3  |            | 0  4  8  12 |         |             |            |             |         | 4  5  6  7  |            | 1  5  9  13 |     M = |             |        M = |             |         | 8  9  10 11 |            | 2  6  10 14 |         |             |            |             |         | 12 13 14 15 |            | 3  7  11 15 | I2. Important note with respect to normalized inputs ----------------------------------------------------   Note that most algorithms assume normalized inputs, such as vectors of   union length, or matrices with normalized main diagonal etc. It is possible,   and often enough the case, that algorithms (and the code snippets provided here)   work correctly with arbitrary inputs, but it is usually considered bad practise   (and you will pay in debugging time if you fail to observe this suggestion) to   rely on this property.    Answers ------- BASICS ====== Q1.  What is a matrix? ----------------------   A matrix is a two dimensional array of numeric data, where each   row or column consists of one or more numeric values.   Arithmetic operations which can be performed with matrices include   addition, subtraction, multiplication and division.   The size of a matrix is defined in terms of the number of rows   and columns.   A matrix with M rows and N columns is defined as a MxN matrix.   Individual elements of the matrix are referenced using two index   values. Using mathematical notation these are usually assigned the   variables 'i' and 'j'. The order is row first, column second   For example, if a matrix M with order 4x4 exists, then the elements   of the matrix are indexed by the following row:column pairs:         | 00 01 02 03 |     M = | 10 11 12 13 |         | 20 21 22 23 |         | 30 31 32 33 |   The element at the top right of the matrix has i=0 and j=3   This is referenced as follows:     M    = M      i,j    0,3   In computer animation, the most commonly used matrices have either   2, 3 or 4 rows and columns. These are referred to as 2x2, 3x3 and 4x4   matrices respectively.   2x2 matrices are used to perform rotations, shears and other types   of image processing. General purpose NxN matrices can be used to   perform image processing functions such as convolution.   3x3 matrices are used to perform low-budget 3D animation. Operations   such as rotation and multiplication can be performed using matrix   operations, but perspective depth projection is performed using   standard optimised into pure divide operations.   4x4 matrices are used to perform high-end 3D animation. Operations   such as multiplication and perspective depth projection can be   performed using matrix mathematics.    Q2.  What is the "order" of a matrix? -------------------------------------   The "order" of a matrix is another name for the size of the matrix.   A matrix with M rows and N columns is said to have order MxN.    Q3.  How do I represent a matrix using the C/C++ programming languages? -----------------------------------------------------------------------   The simplest way of defining a matrix using the C/C++ programming   languages is to make use of the "typedef" keyword. Both 3x3 and 4x4   matrices may be defined in this way ie:     typedef float MATRIX3[9];     typedef float MATRIX4[16];     Since each type of matrix has dimensions 3x3 and 4x4, this requires   9 and 16 data elements respectively.   At first glance, the use of a single linear array of data values may   seem counter-intuitive. The use of two dimensional arrays may seem   more convenient ie.     typedef float MATRIX3[3][3];     typedef float MATRIX4[4][4];   However, the use of two reference systems for each matrix element   very often leads to confusion. With mathemetics, the order is row   first (i), column second (j) ie.      Mij   Using C/C++, this becomes      matrix[j][i]      Using two dimensional arrays also incurs a CPU performance penalty in   that C compilers will often make use of multiplication operations to   resolve array index operations.   So, it is more efficient to stick with linear arrays. However, one issue   still remains to be resolved. How is an two dimensional matrix mapped   onto a linear array? Since there are only two methods (row first/column   second or column first/row column).   The performance differences between the two are subtle. If all for-next   loops are unravelled, then there is very little difference in the   performance for operations such as matrix-matrix multiplication.   Using the C/C++ programming languages the linear ordering of each   matrix is as follows:   mat[0][nbsp][nbsp]= M[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]mat[3][nbsp][nbsp]= M [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 00[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 03 [nbsp][nbsp]mat[12] = M[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]mat[15] = M [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 30[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 33 |[nbsp][nbsp]0[nbsp][nbsp]1[nbsp][nbsp]2[nbsp][nbsp]3 | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]|[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] |[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| 0 1 2 | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]|[nbsp][nbsp]4[nbsp][nbsp]5[nbsp][nbsp]6[nbsp][nbsp]7 |[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]|[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] | [nbsp][nbsp][nbsp][nbsp]M = |[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] |[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]M = | 3 4 5 | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]|[nbsp][nbsp]8[nbsp][nbsp]9 10 11 |[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]|[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]|[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] |[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| 6 7 8 | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| 12 13 14 15 | Q4.[nbsp][nbsp]What are the advantages of using matrices? ----------------------------------------------- [nbsp][nbsp]One of the first questions asked about the use of matrices in computer [nbsp][nbsp]animation is why they should be used at all in the first place. [nbsp][nbsp]Intuitively, it would appear that the overhead of for-next loops and [nbsp][nbsp]matrix multiplication would slow down an application. [nbsp][nbsp]Arguments that resolve these objections can be pointed out. These include [nbsp][nbsp]the use of CPU registers to handle loop counters on-board data caches [nbsp][nbsp]to optimise memory accesses. [nbsp][nbsp]Advantages can also be pointed out. By following a mathematical approach [nbsp][nbsp]to defining 3D algorithms, it is possible to predict and plan the [nbsp][nbsp]design of a 3D animation system. Such mathematical approaches allow [nbsp][nbsp]for the implementation of character animation, spline curves and inverse [nbsp][nbsp]kinematics. [nbsp][nbsp]However, one objection that frequently comes up is that it would be [nbsp][nbsp]quicker to just multiply each pair of coordinates by the rotation [nbsp][nbsp]coefficients for that axis, rather than perform a full vector-matrix [nbsp][nbsp]multiplication. [nbsp][nbsp]ie. Rotation in X transforms Y and Z [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]Rotation in Y transforms X and Z [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]Rotation in Z transforms X and Y [nbsp][nbsp]The argument to this goes as follows: [nbsp][nbsp]Given a vertex V = (x,y,z), rotation angles (A,B and C) and translation [nbsp][nbsp](D,E,F). A[nbsp][nbsp]the algorithm [nbsp][nbsp]is defined as follows: [nbsp][nbsp][nbsp][nbsp]--------------------------- [nbsp][nbsp][nbsp][nbsp]sx = sin(A)[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] // Setup - only done once [nbsp][nbsp][nbsp][nbsp]cx = cos(A) [nbsp][nbsp][nbsp][nbsp]sy = sin(B) [nbsp][nbsp][nbsp][nbsp]cy = cos(B) [nbsp][nbsp][nbsp][nbsp]sz = sin© [nbsp][nbsp][nbsp][nbsp]cz = cos© [nbsp][nbsp][nbsp][nbsp]x1 =[nbsp][nbsp]x * cz +[nbsp][nbsp]y * sz[nbsp][nbsp]// Rotation of each vertex [nbsp][nbsp][nbsp][nbsp]y1 =[nbsp][nbsp]y * cz -[nbsp][nbsp]x * sz [nbsp][nbsp][nbsp][nbsp]z1 =[nbsp][nbsp]z [nbsp][nbsp][nbsp][nbsp]x2 = x1 * cy + z1 * sy [nbsp][nbsp][nbsp][nbsp]y2 = z1 [nbsp][nbsp][nbsp][nbsp]z2 = z1 * cy - x1 * sy [nbsp][nbsp][nbsp][nbsp]x3 = x2 [nbsp][nbsp][nbsp][nbsp]y3 = y2 * cx + z1 * sx [nbsp][nbsp][nbsp][nbsp]z3 = z2 * cx - x1 * sx [nbsp][nbsp][nbsp][nbsp]xr = x3 + D[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] // Translation of each vertex [nbsp][nbsp][nbsp][nbsp]yr = y3 + E [nbsp][nbsp][nbsp][nbsp]zr = z3 + F [nbsp][nbsp][nbsp][nbsp]--------------------------- [nbsp][nbsp]Altogether, this algorithm will use the following amounts of processing [nbsp][nbsp]time: [nbsp][nbsp][nbsp][nbsp]Set-up[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] Per-vertex [nbsp][nbsp][nbsp][nbsp]-------------------------[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]------------------------ [nbsp][nbsp][nbsp][nbsp]6 trigonometric functions [nbsp][nbsp][nbsp][nbsp]6 assignment operations.[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 12 assignment [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 12 multiplication [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]9 addition [nbsp][nbsp][nbsp][nbsp]-------------------------[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]------------------------ [nbsp][nbsp]Assume that the same operations is being performed using matrix [nbsp][nbsp]multiplication. [nbsp][nbsp]With a 4x4 matrix, the procesing time is used as follows: [nbsp][nbsp][nbsp][nbsp]Set-up[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] Change[nbsp][nbsp][nbsp][nbsp]Per-vertex[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] Change [nbsp][nbsp][nbsp][nbsp]--------------------------[nbsp][nbsp] ------[nbsp][nbsp][nbsp][nbsp]------------------------ ------ [nbsp][nbsp][nbsp][nbsp]6[nbsp][nbsp]trigonometric functions[nbsp][nbsp][nbsp][nbsp]0[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]0 [nbsp][nbsp][nbsp][nbsp]18 assignment operation[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]-12[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]3[nbsp][nbsp]assignment[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] -9 [nbsp][nbsp][nbsp][nbsp]12 multiplication[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]+12[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]9[nbsp][nbsp]multiplication[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] -3 [nbsp][nbsp][nbsp][nbsp]6[nbsp][nbsp]subtraction[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] +6[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] 6[nbsp][nbsp]addition[nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp] -3 [nbsp][nbsp][nbsp][nbsp]--------------------------[nbsp][nbsp] ------[nbsp][nbsp][nbsp][nbsp]------------------------ ------ [nbsp][nbsp]Comparing the two tables, it can be seen that setting up a rotation [nbsp][nbsp]matrix costs at least 12 multiplication calculations and an extra [nbsp][nbsp]18 assignment calls. [nbsp][nbsp]However, while this may seem extravagant, the savings come from [nbsp][nbsp]processing each vertex. Using matrix multiplication, the savings made [nbsp][nbsp]from processing just 4 vertices, will outweigh the additional set-up [nbsp][nbsp]cost. [nbsp][nbsp] Q5.[nbsp][nbsp]How do matrices relate to coordinate systems? -------------------------------------------------- [nbsp][nbsp]With either 3x3 or 4x4 rotation, translation or shearing matrices, there [nbsp][nbsp]is a simple relationship between each matrix and the resulting coordinate [nbsp][nbsp]system. [nbsp][nbsp]The first three columns of the matrix define the direction vector of the [nbsp][nbsp]X, Y and Z axii respectively. [nbsp][nbsp]If a 4x4 matrix is defined as: [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| A B C D | [nbsp][nbsp][nbsp][nbsp]M = | E F G H | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| I J K L | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| M N O P | [nbsp][nbsp]Then the direction vector for each axis is as follows: [nbsp][nbsp][nbsp][nbsp] X-axis = [ A E I ] [nbsp][nbsp][nbsp][nbsp] Y-axis = [ B F J ] [nbsp][nbsp][nbsp][nbsp] Z-axis = [ C G K ] [nbsp][nbsp][nbsp][nbsp] ARITHMETIC ========== Q6.[nbsp][nbsp]What is the identity matrix? --------------------------------- [nbsp][nbsp]The identity matrix is matrix in which has an identical number of rows [nbsp][nbsp]and columns. Also, all the elements in which i=j are set one. All others [nbsp][nbsp]are set to zero. For example a 4x4 identity matrix is as follows: [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| 1 0 0 0 | [nbsp][nbsp][nbsp][nbsp]M = | 0 1 0 0 | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| 0 0 1 0 | [nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp][nbsp]| 0 0 0 1 | Q7.[nbsp][nbsp]What is the major diagonal of a matrix? -------------------------------------------- [nbsp][nbsp]The major diagonal of a matrix is the set of elements where the [nbsp][nbsp]row number is equal to the column number ie. [nbsp][nbsp][nbsp][nbsp]M[nbsp][nbsp] where i=j [nbsp][nbsp][nbsp][nbsp] ij [nbsp][nbsp]In the case of the identity matrix, only the elements on the major [nbsp][nbsp]diagonal are set to 1, while all others are set to 0. [nbsp][nbsp] Comments Note: Please offer only positive, constructive comments - we are looking to promote a positive atmosphere where collaboration is valued above all else. Home » Home » Articles » Technical » Math and Physics » Article: The Matrix and Quaternions FAQ English (USA) English (USA) English (USA) (COPY) Mark Community Read Forums Members Developer Journals Gallery Downloads Resources Store Classifieds Tracker Links Mark all as read Help PARTNERS Copyright © 1999-2015 GameDev.Net LLC GameDev.net™, the GameDev.net logo, and GDNet™ are trademarks of GameDev.net, LLC Navigation Home For Beginners Technical Creative Business Customer Service GDNet+ Subscriptions Job Advertising Terms of Service Privacy Policy Company Info About Us Advertise on Gamedev.net Contact Us Sign In   Use Google   Use Facebook   Use Twitter Need an account? Register now! Username Password I've forgotten my password Remember me This is not recommended for shared computers Sign in anonymously Don't add me to the active users list Privacy Policy